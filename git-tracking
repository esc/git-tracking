#!/bin/bash
# Maintain local tracking braches
# fast-forward local tracking branch if you get something like (on git checkout):
# Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.
# Author: Valentin Haenel <valentin.haenel@gmx.de>
# Licence: wtfpl <http://sam.zoy.org/wtfpl/>

# detect branch names
BRANCH=$( git branch | grep ^* | sed 's/^\* //' )
if [[ -z $BRANCH ]] ; then
    # not a git repository
    exit 1
elif [[ $BRANCH == '(no branch)' ]] ; then
    echo 'You have a detached HEAD.'
    exit 2
fi
REMOTE=$( git config branch.$BRANCH.remote )
REMOTE_BRANCH=$( git config branch.$BRANCH.merge | sed 's,^refs/heads/,,')

check_no_tracking (){
if [[ -z $REMOTE ]] ; then
    echo "Your branch '$BRANCH' isn't tracking anything."
    exit 3
fi
}

ff() {
    check_no_tracking
    if [[ -n $REMOTE && -n $( git config branch.$BRANCH.merge) ]] ; then
        remote_ahead_local=$( git log --oneline $BRANCH..$REMOTE/$BRANCH)
        local_ahead_remote=$( git log --oneline $REMOTE/$BRANCH..$BRANCH)
        if [[ -z $remote_ahead_local && -z $local_ahead_remote ]] ; then
                if [[ $( git rev-parse $BRANCH )  == $( git rev-parse $REMOTE/$BRANCH ) ]] ; then
                    echo "Your branch '$BRANCH' points to same commit as '$REMOTE/$BRANCH', doing nothing."
                    exit 4
                else
                    echo "Dude..."
                    exit 42
                fi
        fi
        if [[ -z $remote_ahead_local && -n $local_ahead_remote ]] ; then
            echo "Your branch '$BRANCH'is ahead of '$REMOTE/$BRANCH', perhaps you want to push?"
            exit 5
        fi
        if [[ -n $local_ahead_remote && -n $remote_ahead_local ]] ; then
            echo "Your branches '$BRANCH' and '$REMOTE/$BRANCH' and have diverged, fast-forward not possible!"
            exit 6
        fi
        if [[ -n $remote_ahead_local && -z $local_ahead_remote ]] ; then
            echo "Fast-forward '$BRANCH' to '$REMOTE/$BRANCH'."
            git merge --ff-only $REMOTE/$BRANCH
            exit 0
        fi
    fi
}

parse_start_tracking() {
    if [[ -z $2 ]] ; then
        print_usage
    fi
    if [[ $2 == "--force" || $2 == "-f" ]] ; then
        FORCE=true
        shift
    fi
    if [[ -n $REMOTE && -z $FORCE ]] ; then
        echo "Your branch '$BRANCH' is already tracking '$REMOTE/$BRANCH'"
        echo "Either use 'git tracking stop' first or --force(-f)."
        exit
    elif [[ -n $REMOTE && $FORCE ]] ; then
        stop_tracking
    fi
    start_tracking $2
}

start_tracking(){
    if [[ $1 != */* ]]; then
        echo "Remote tracking branch was not specified as <remote>/<branch>."
        echo "Available remote tracking branches are:"
        git branch -r
        exit
    fi
    remote_branch=$( echo $1 | sed 's,^.*/,,')
    new_remote=$( echo $1 | sed 's,/.*$,,')
    if [[ -z $( git remote | grep $new_remote) ]]  ;then
        echo "Can not start tracking, remote '$new_remote' does not exist!"
        exit
    fi
    if [[ -z $( git branch -r | grep $new_remote/$remote_branch ) ]] ; then
        echo "Can not start tracking, remote '$new_remote' does not appear to have a branch '$remote_branch'"
        exit
    fi
    git config branch.$BRANCH.remote $new_remote
    git config branch.$BRANCH.merge 'refs/heads/'$remote_branch
    echo "Branch '$BRANCH' setup to track remote branch '$remote_branch' from '$new_remote'."
    exit 0
}

stop_tracking() {
    check_no_tracking
    git config --remove-section branch.$BRANCH
    echo "Branch '$BRANCH' is no longer tracking '$REMOTE/$REMOTE_BRANCH'."
}

review() {
return
}

print_usage(){
cat << END
usage: git tracking [ff | start <ref> | stop | review]
END
exit
}

case $1 in
    "")
        print_usage ;;
    "ff")
        ff ;;
    "start")
        parse_start_tracking $@ ;;
    "stop")
        stop_tracking ;;
    "status")
        # rewrite this and format output neater
        git branch -vv ;;
    "review")
        review ;;
    *)
        print_usage $@ ;;
esac
